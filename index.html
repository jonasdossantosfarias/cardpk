<html><head><base href="/" />
<title>An√°lise de Poker Inteligente</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f8f9fa;
        color: #212529;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
    }
    h2 {
        font-size: 1.5rem;
        color: #495057;
        margin: 20px 0 10px 0;
    }
    .deck {
        display: grid;
        grid-template-columns: repeat(13, minmax(40px, 1fr));
        grid-template-rows: repeat(4, auto);
        gap: 8px;
        justify-content: center;
        padding: 10px;
        background: #ffffff;
        border: 1px solid #ced4da;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        margin-top: 20px;
        width: 95%;
        max-width: 1200px;
    }
    .card {
        width: 100%;
        aspect-ratio: 0.7;
        min-width: 30px;
        max-width: 50px;
        height: auto;
        border-radius: 5px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: clamp(10px, 2vw, 14px);
        cursor: pointer;
        transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        position: relative;
        overflow: hidden;
        background-color: #ffffff;
        border: 1px solid #ced4da;
    }
    .card:before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 50%);
        pointer-events: none;
    }
    .card.red { color: #e74c3c; }
    .card.black { color: #212529; }
    .card:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
    }
    .selected-hand {
        background-color: #3498db;
        color: white !important;
        border-color: #2980b9;
        box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
    }
    .selected-community.pre-flop {
        background-color: #e67e22;
        color: white !important;
        border-color: #d35400;
        box-shadow: 0 4px 8px rgba(230, 126, 34, 0.3);
    }
    .selected-community.turn {
        background-color: #9b59b6;
        color: white !important;
        border-color: #8e44ad;
        box-shadow: 0 4px 8px rgba(155, 89, 182, 0.3);
    }
    .selected-community.river {
        background-color: #e74c3c;
        color: white !important;
        border-color: #c0392b;
        box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
    }
    .controls {
        margin: 20px 0;
        padding: 15px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        width: 95%;
        max-width: 800px;
    }
    button {
        padding: 8px 15px;
        font-size: 14px;
        border: none;
        background-color: #3498db;
        color: white;
        border-radius: 5px;
        cursor: pointer;
        margin: 2px;
    }
    button:hover {
        opacity: 0.9;
    }
    button.active {
        background-color: #e74c3c;
    }
    .info-container {
        margin: 15px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        width: 95%;
        max-width: 800px;
    }
    select {
        padding: 5px 10px;
        border-radius: 5px;
        border: 1px solid #ced4da;
        margin-right: 10px;
    }
    @media (max-width: 768px) {
        .deck {
            gap: 4px;
            padding: 5px;
        }
        
        .card {
            min-width: 25px;
        }
    }

    @media (max-width: 480px) {
        .deck {
            gap: 2px;
            padding: 3px;
        }
    }
    
    .opponent-controls,
    .opponent-panel {
        display: none;
    }
    #recommendation {
        margin-bottom: 10px;
        font-size: 16px;
        color: #343a40;
        line-height: 1.5;
    }

    #recommendation strong {
        color: #2c3e50;
    }

    #recommendation br {
        margin-bottom: 5px;
    }
</style>
</head>
<body>
    <h2>An√°lise de Poker Inteligente</h2>
    <div class="controls">
        <button onclick="initializeDeck()">Reiniciar Jogo</button>
    </div>
    <div class="info-container">
        <div id="recommendation" style="margin-bottom: 10px; font-size: 16px; color: #343a40;">Recomenda√ß√£o: </div>
        <div id="probabilities" style="margin-bottom: 10px; font-size: 14px; color: #6c757d;">Probabilidades: </div>
    </div>
    <div class="deck" id="deck"></div>

<script>
const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
const suits = ['‚ô†', '‚ô•', '‚ô£', '‚ô¶'];

let deck = [];
let playerHand = [];
let communityCards = [];

function evaluateHand(cards) {
    if (cards.length === 0) return { type: 'M√£o vazia', strength: 0 };
    
    const formattedCards = cards.map(card => ({
        value: card.slice(0, -1),
        suit: card.slice(-1)
    }));

    const valueCounts = {};
    const suitCounts = {};
    formattedCards.forEach(card => {
        valueCounts[card.value] = (valueCounts[card.value] || 0) + 1;
        suitCounts[card.suit] = (suitCounts[card.suit] || 0) + 1;
    });

    // Check for each hand type
    const hasFlush = Object.values(suitCounts).some(count => count >= 5);
    const hasQuads = Object.values(valueCounts).some(count => count === 4);
    const hasTrips = Object.values(valueCounts).some(count => count === 3);
    const pairCount = Object.values(valueCounts).filter(count => count === 2).length;

    // Check for straight
    const sortedValues = [...new Set(formattedCards.map(card => values.indexOf(card.value)))].sort((a, b) => a - b);
    let hasStraight = false;
    let isRoyal = false;
    
    for (let i = 0; i <= sortedValues.length - 5; i++) {
        if (sortedValues[i + 4] - sortedValues[i] === 4) {
            hasStraight = true;
            // Check if it's a Royal Straight (10 through Ace)
            if (sortedValues[i + 4] === values.indexOf('A') && sortedValues[i] === values.indexOf('10')) {
                isRoyal = true;
            }
            break;
        }
    }

    // Return hand ranking with detailed information
    if (isRoyal && hasFlush) {
        return { type: '1 - Sequ√™ncia Real Royal', strength: 1.0, detail: 'Royal Flush - Melhor m√£o poss√≠vel!' };
    }
    if (hasFlush && hasStraight) {
        return { type: '2 - Sequ√™ncia Straight Flush', strength: 0.95, detail: 'Straight Flush - M√£o extremamente forte!' };
    }
    if (hasQuads) {
        return { type: '3 - Quadra', strength: 0.9, detail: 'Quadra - M√£o muito forte!' };
    }
    if (hasTrips && pairCount >= 1) {
        return { type: '4 - Full House', strength: 0.85, detail: 'Full House - M√£o muito forte!' };
    }
    if (hasFlush) {
        return { type: '5 - Flush', strength: 0.8, detail: 'Flush - M√£o forte!' };
    }
    if (hasStraight) {
        return { type: '6 - Sequ√™ncia', strength: 0.75, detail: 'Sequ√™ncia completa' };
    }
    if (hasTrips) {
        return { type: '7 - Trinca', strength: 0.7, detail: 'Trinca - M√£o m√©dia-forte' };
    }
    if (pairCount === 2) {
        return { type: '8 - Dois Pares', strength: 0.6, detail: 'Dois pares - M√£o m√©dia' };
    }
    if (pairCount === 1) {
        return { type: '9 - Par', strength: 0.5, detail: `Par de ${formattedCards.find(card => valueCounts[card.value] === 2).value}s` };
    }

    // For high card hands, determine if it's high or low
    const highestCard = Math.max(...sortedValues);
    if (highestCard >= values.indexOf('J')) {
        return { type: '10 - Carta Alta', strength: 0.3, detail: `Carta alta ${values[highestCard]}` };
    }
    
    return { type: '11 - Carta Baixa', strength: 0.2, detail: `Carta baixa ${values[highestCard]}` };
}

// Update the checkStraightPotential function to be more focused on sequences
function checkStraightPotential(handCards, communityCards, valueOrder) {
    const holeValues = handCards.map(card => card.slice(0, -1));
    const holeIndexes = holeValues.map(v => valueOrder.indexOf(v));
    
    let results = [];
    
    // Pre-flop analysis
    if (handCards.length === 2) {
        const holeDiff = Math.abs(holeIndexes[0] - holeIndexes[1]);
        const highCard = Math.max(...holeIndexes);
        const lowCard = Math.min(...holeIndexes);
        
        // Connected cards
        if (holeDiff === 1) {
            results.push({
                stage: "Pr√©-flop",
                detail: `Sequ√™ncia potencial direta: ${holeValues[0]}-${holeValues[1]}`,
                probability: highCard > 9 ? 35 : 30
            });
        } 
        // One gap
        else if (holeDiff === 2) {
            results.push({
                stage: "Pr√©-flop",
                detail: `Sequ√™ncia com um espa√ßo: ${holeValues[0]}-${holeValues[1]}`,
                probability: highCard > 9 ? 28 : 23
            });
        } 
        // Two gap
        else if (holeDiff === 3) {
            results.push({
                stage: "Pr√©-flop",
                detail: `Sequ√™ncia com dois espa√ßos: ${holeValues[0]}-${holeValues[1]}`,
                probability: highCard > 9 ? 20 : 15
            });
        }
    }

    // Post-flop analysis
    if (communityCards.length > 0) {
        const allCards = [...handCards, ...communityCards];
        const allValues = allCards.map(c => valueOrder.indexOf(c.slice(0, -1)))
                                .sort((a, b) => a - b);
        
        let maxSequence = 1;
        let currentSequence = 1;
        let sequenceCards = [valueOrder[allValues[0]]];
        
        for (let i = 1; i < allValues.length; i++) {
            if (allValues[i] === allValues[i-1] + 1) {
                currentSequence++;
                sequenceCards.push(valueOrder[allValues[i]]);
            } else if (allValues[i] !== allValues[i-1]) {
                if (currentSequence > maxSequence) {
                    maxSequence = currentSequence;
                }
                currentSequence = 1;
                sequenceCards = [valueOrder[allValues[i]]];
            }
        }
        
        maxSequence = Math.max(maxSequence, currentSequence);
        
        if (maxSequence >= 3) {
            const remainingNeeded = 5 - maxSequence;
            const stage = communityCards.length === 3 ? "Flop" : 
                         communityCards.length === 4 ? "Turn" : "River";
            
            const probability = maxSequence === 4 ? 45 :
                              maxSequence === 3 ? 30 : 15;
            
            results.push({
                stage: stage,
                detail: `${maxSequence} cartas em sequ√™ncia (${sequenceCards.join('-')}), faltam ${remainingNeeded}`,
                probability: probability
            });
        }
    }

    return results;
}

// Update the updateGameState function to show sequence information more clearly
function getGameAdvice(handStrength, probabilities, stage) {
    const strengthValue = parseFloat(handStrength);
    const winProb = parseFloat(probabilities.win);
    
    // Define thresholds for different actions
    let advice = '';
    
    // Pre-flop advice
    if (stage === 'pre-flop') {
        if (strengthValue >= 0.8) {
            advice = "üî• M√£o muito forte! Aumente a aposta agressivamente.";
        } else if (strengthValue >= 0.6) {
            advice = "üëç Boa m√£o! Continue no jogo e considere aumentar.";
        } else if (strengthValue >= 0.4) {
            advice = "ü§î M√£o mediana. Veja o flop se o custo for baixo.";
        } else {
            advice = "üëé M√£o fraca. Considere desistir a menos que o blind seja baixo.";
        }
    }
    // Post-flop advice
    else {
        if (winProb >= 75) {
            advice = "üî• Probabilidade excelente! Aposte forte.";
        } else if (winProb >= 60) {
            advice = "üí™ Boa posi√ß√£o! Fa√ßa apostas moderadas.";
        } else if (winProb >= 45) {
            advice = "‚öñÔ∏è Situa√ß√£o equilibrada. Jogue com cautela e observe as apostas dos oponentes.";
        } else if (winProb >= 30) {
            advice = "‚ö†Ô∏è Probabilidade baixa. Considere blefar se os oponentes mostrarem fraqueza.";
        } else {
            advice = "‚ùå Probabilidade muito baixa. Desista se houver apostas significativas.";
        }
    }

    // Additional strategic considerations
    if (stage === 'river' && winProb >= 40 && winProb <= 55) {
        advice += "\nüí° Momento cr√≠tico para blefe se os oponentes mostrarem indecis√£o.";
    }

    return advice;
}

function updateGameState() {
    if (playerHand.length === 2) {
        const handEval = evaluateHand([...playerHand, ...communityCards]);
        const straightResults = checkStraightPotential(playerHand, communityCards, values);
        
        let output = `<strong>For√ßa da M√£o:</strong> ${handEval.type} - ${handEval.detail}<br>`;
        
        if (straightResults.length > 0) {
            output += "<br><strong>An√°lise de Sequ√™ncia:</strong><br>";
            straightResults.forEach(result => {
                output += `‚Ä¢ ${result.stage}: ${result.detail}<br>`;
                output += `  Probabilidade de completar: ${result.probability}%<br>`;
            });
        }

        // Add game advice
        const stage = communityCards.length === 0 ? 'pre-flop' : 
                     communityCards.length === 3 ? 'flop' :
                     communityCards.length === 4 ? 'turn' : 'river';
        
        const stats = calculateProbabilitiesAgainstOpponents(playerHand, communityCards, 2); // Assuming average 2 opponents
        const advice = getGameAdvice(handEval.strength, stats, stage);
        
        output += `<br><strong>üí≠ Dica Estrat√©gica:</strong><br>${advice}`;
        
        document.getElementById('recommendation').innerHTML = output;
        updateProbabilities();
    }
}

function calculateOutsAndOdds(currentCards, availableCards) {
    const outs = [];
    const odds = {};
    
    if (currentCards.length < 2) return { outs, odds };

    const canMakeStraight = (cards) => {
        const cardValues = cards.map(card => {
            const val = card.slice(0, -1);
            return values.indexOf(val);
        }).sort((a, b) => a - b);
        
        let gaps = 0;
        for (let i = 1; i < cardValues.length; i++) {
            gaps += cardValues[i] - cardValues[i-1] - 1;
        }
        return gaps <= 2;
    };

    const possibleHands = {
        'Royal Flush': { probability: 0, cards: [] },
        'Straight Flush': { probability: 0, cards: [] },
        'Quadra': { probability: 0, cards: [] },
        'Full House': { probability: 0, cards: [] },
        'Flush': { probability: 0, cards: [] },
        'Sequ√™ncia': { probability: 0, cards: [] }
    };

    if (canMakeStraight(currentCards)) {
        possibleHands['Sequ√™ncia'].probability = 15;
    }

    const suitCounts = {};
    currentCards.forEach(card => {
        const suit = card.slice(-1);
        suitCounts[suit] = (suitCounts[suit] || 0) + 1;
    });

    Object.entries(suitCounts).forEach(([suit, count]) => {
        if (count >= 3) {
            possibleHands['Flush'].probability = 20;
        }
    });

    return { outs, odds: possibleHands };
}

function calculateWinProbability() {
    const handEval = evaluateHand([...playerHand, ...communityCards]);
    let probability = handEval.strength;
    
    const availableCards = deck.filter(card => 
        !playerHand.includes(card) && !communityCards.includes(card));
    const { outs } = calculateOutsAndOdds([...playerHand, ...communityCards], availableCards);
    
    if (outs.length > 0) {
        const outsBonus = (outs.length / 47) * 0.3;
        probability += outsBonus;
    }

    return Math.min(Math.max(probability, 0), 1);
}

function calculateProbabilitiesAgainstOpponents(myCards, communityCards, opponentCount) {
    const handEval = evaluateHand([...myCards, ...communityCards]);
    let baseWinProb = handEval.strength;
    
    const opponentAdjustment = {
        1: 0.9,
        2: 0.8,
        3: 0.7,
        4: 0.6
    };

    let winProb = baseWinProb * opponentAdjustment[opponentCount];
    
    if (communityCards.length === 0) {
        winProb *= 0.9;
    } else if (communityCards.length <= 3) {
        winProb *= 0.95;
    }

    let tieProb = 0.05 / opponentCount;
    let loseProb = 1 - winProb - tieProb;

    winProb = Math.min(Math.max(winProb, 0), 1);
    loseProb = Math.min(Math.max(loseProb, 0), 1);
    tieProb = Math.min(Math.max(tieProb, 0), 1);

    return {
        win: (winProb * 100).toFixed(1),
        lose: (loseProb * 100).toFixed(1),
        tie: (tieProb * 100).toFixed(1)
    };
}

function updateProbabilities() {
    if (playerHand.length !== 2) return;
    
    const probs = document.getElementById('probabilities');
    let output = '<strong>Probabilidades por n¬∫ de oponentes:</strong><br>';
    
    for (let i = 1; i <= 4; i++) {
        const stats = calculateProbabilitiesAgainstOpponents(playerHand, communityCards, i);
        output += `${i} oponente${i > 1 ? 's' : ''}: V:${stats.win}% D:${stats.lose}% E:${stats.tie}% | `;
        if (i % 2 === 0) output += '<br>';
    }
    
    probs.innerHTML = output;
}

function initializeDeck() {
    deck = [];
    values.forEach(value => {
        suits.forEach(suit => {
            deck.push(`${value}${suit}`);
        });
    });
    renderDeck();
}

function renderDeck() {
    const deckElement = document.getElementById('deck');
    deckElement.innerHTML = '';
    deck.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.includes('‚ô•') || card.includes('‚ô¶') ? 'red' : 'black'}`;
        cardElement.textContent = card;
        cardElement.addEventListener('click', () => toggleCardSelection(card, cardElement));
        deckElement.appendChild(cardElement);
    });
}

function toggleCardSelection(card, cardElement) {
    if (cardElement.classList.contains('selected-hand') || 
        cardElement.classList.contains('selected-community')) {
        if (cardElement.classList.contains('selected-hand')) {
            playerHand = playerHand.filter(c => c !== card);
        } else {
            communityCards = communityCards.filter(c => c !== card);
        }
        cardElement.className = `card ${card.includes('‚ô•') || card.includes('‚ô¶') ? 'red' : 'black'}`;
    } else {
        if (playerHand.length < 2) {
            playerHand.push(card);
            cardElement.classList.add('selected-hand');
        } else if (communityCards.length < 3) {
            communityCards.push(card);
            cardElement.classList.add('selected-community', 'pre-flop');
        } else if (communityCards.length === 3) {
            communityCards.push(card);
            cardElement.classList.add('selected-community', 'turn');
        } else if (communityCards.length === 4) {
            communityCards.push(card);
            cardElement.classList.add('selected-community', 'river');
        }
    }
    updateGameState();
}

// Initialize the game
initializeDeck();
</script>

</body></html>
