<html><head><base href="/" />
<title>Análise de Poker Inteligente</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f8f9fa;
        color: #212529;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
    }
    h2 {
        font-size: 1.5rem;
        color: #495057;
        margin: 20px 0 10px 0;
    }
    .deck {
        display: grid;
        grid-template-columns: repeat(13, minmax(40px, 1fr));
        grid-template-rows: repeat(4, auto);
        gap: 8px;
        justify-content: center;
        padding: 10px;
        background: #ffffff;
        border: 1px solid #ced4da;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        margin-top: 20px;
        width: 95%;
        max-width: 1200px;
    }
    .card {
        width: 100%;
        aspect-ratio: 0.7;
        min-width: 30px;
        max-width: 50px;
        height: auto;
        border-radius: 5px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: clamp(10px, 2vw, 14px);
        cursor: pointer;
        transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        position: relative;
        overflow: hidden;
        background-color: #ffffff;
        border: 1px solid #ced4da;
    }
    .card:before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 50%);
        pointer-events: none;
    }
    .card.red { color: #e74c3c; }
    .card.black { color: #212529; }
    .card:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
    }
    .selected-hand {
        background-color: #3498db;
        color: white !important;
        border-color: #2980b9;
        box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
    }
    .selected-community.pre-flop {
        background-color: #e67e22;
        color: white !important;
        border-color: #d35400;
        box-shadow: 0 4px 8px rgba(230, 126, 34, 0.3);
    }
    .selected-community.turn {
        background-color: #9b59b6;
        color: white !important;
        border-color: #8e44ad;
        box-shadow: 0 4px 8px rgba(155, 89, 182, 0.3);
    }
    .selected-community.river {
        background-color: #e74c3c;
        color: white !important;
        border-color: #c0392b;
        box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
    }
    .controls {
        margin: 20px 0;
        padding: 15px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        width: 95%;
        max-width: 800px;
    }
    .opponent-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin: 10px 0;
        width: 95%;
        max-width: 800px;
    }
    .opponent-panel {
        background: #f8f9fa;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #dee2e6;
    }
    button {
        padding: 8px 15px;
        font-size: 14px;
        border: none;
        background-color: #3498db;
        color: white;
        border-radius: 5px;
        cursor: pointer;
        margin: 2px;
    }
    button:hover {
        opacity: 0.9;
    }
    button.active {
        background-color: #e74c3c;
    }
    .info-container {
        margin: 15px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        width: 95%;
        max-width: 800px;
    }
    select {
        padding: 5px 10px;
        border-radius: 5px;
        border: 1px solid #ced4da;
        margin-right: 10px;
    }
    @media (max-width: 768px) {
        .deck {
            gap: 4px;
            padding: 5px;
        }
        
        .card {
            min-width: 25px;
        }
    }

    @media (max-width: 480px) {
        .deck {
            gap: 2px;
            padding: 3px;
        }
    }
</style>
</head>
<body>
    <h2>Análise de Poker Inteligente</h2>
    <div class="controls">
        <select id="opponentCount">
            <option value="1">1 Oponente</option>
            <option value="2">2 Oponentes</option>
            <option value="3">3 Oponentes</option>
            <option value="4">4 Oponentes</option>
        </select>
        <button onclick="updateOpponentControls()">Atualizar Oponentes</button>
    </div>
    <div id="opponentActions" class="opponent-controls"></div>
    <div class="info-container">
        <div id="recommendation" style="margin-bottom: 10px; font-size: 16px; color: #343a40;">Recomendação: </div>
        <div id="probabilities" style="margin-bottom: 10px; font-size: 14px; color: #6c757d;">Probabilidades: </div>
        <div id="opponent-analysis" style="font-size: 14px; color: #6c757d;">Análise dos oponentes: </div>
        <div id="predicted-hands" style="font-size: 14px; color: #6c757d; margin-top: 10px;">Mãos prováveis dos oponentes: </div>
    </div>
    <div class="deck" id="deck"></div>

<script>
function analyzeCardCounts(cards) {
    const suits = {};
    const ranks = {};
    cards.forEach(card => {
        const suit = card.slice(-1);
        const rank = card.slice(0, -1);
        suits[suit] = (suits[suit] || 0) + 1;
        ranks[rank] = (ranks[rank] || 0) + 1;
    });
    return { suits, ranks };
}

function calculateOutsAndOdds(cards, availableCards) {
    const outs = [];
    const odds = {};
    const analysis = analyzeCardCounts(cards);
    
    // Flush draws
    Object.entries(analysis.suits).forEach(([suit, count]) => {
        if (count === 4) {
            const flushOuts = availableCards.filter(card => card.endsWith(suit));
            outs.push(...flushOuts);
            odds.flush = (flushOuts.length / availableCards.length) * 100;
        }
    });

    // Straight draws
    if (hasStraightDraw(cards)) {
        const straightOuts = findStraightCompletionCards(cards)
            .filter(card => availableCards.includes(card));
        outs.push(...straightOuts);
        odds.straight = (straightOuts.length / availableCards.length) * 100;
    }

    // Pair/Set draws
    Object.entries(analysis.ranks).forEach(([rank, count]) => {
        if (count === 2) {
            const setOuts = availableCards.filter(card => card.startsWith(rank));
            if (setOuts.length > 0) {
                outs.push(...setOuts);
                odds.set = (setOuts.length / availableCards.length) * 100;
            }
        }
    });

    return { outs: [...new Set(outs)], odds };
}

const suits = ['♥', '♦', '♣', '♠'];
const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
let deck = [];
let playerHand = [];
let communityCards = [];
let opponents = [];
let currentPhase = 'hand'; // Can be: 'hand', 'pre-flop', 'flop', 'river'
let opponentHands = [];

let blinds = {
    small: 10,
    big: 20
};

function getBlindsString() {
    return `Small: ${blinds.small}, Big: ${blinds.big}`;
}

function getKickersString(cards) {
    if (cards.length < 2) return [];
    const ranks = cards.map(card => card.slice(0, -1));
    return ranks.sort((a,b) => values.indexOf(b) - values.indexOf(a)).slice(1);
}

function isStraightFlush(cards) {
    return isFlush(cards) && isStraight(cards);
}

function isRoyalFlush(cards) {
    return isStraightFlush(cards) && cards.some(card => card.startsWith('A'));
}

function isFlush(cards) {
    if (cards.length < 5) return false;
    const suits = cards.map(card => card.slice(-1));
    return suits.every(suit => suit === suits[0]);
}

function isStraight(cards) {
    if (cards.length < 5) return false;
    const ranks = cards.map(card => values.indexOf(card.slice(0, -1))).sort((a, b) => a - b);
    for (let i = 1; i < ranks.length; i++) {
        if (ranks[i] !== ranks[i-1] + 1) return false;
    }
    return true;
}

function isPair(cards) {
    const ranks = cards.map(card => card.slice(0, -1));
    return new Set(ranks).size < ranks.length;
}

function isFullHouse(cards) {
    const rankCounts = {};
    cards.forEach(card => {
        const rank = card.slice(0, -1);
        rankCounts[rank] = (rankCounts[rank] || 0) + 1;
    });
    return Object.values(rankCounts).includes(3) && Object.values(rankCounts).includes(2);
}

function isQuads(cards) {
    const ranks = {};
    cards.forEach(card => {
        const rank = card.slice(0, -1);
        ranks[rank] = (ranks[rank] || 0) + 1;
    });
    return Object.values(ranks).some(count => count === 4);
}

function isThreeOfAKind(cards) {
    const ranks = {};
    cards.forEach(card => {
        const rank = card.slice(0, -1);
        ranks[rank] = (ranks[rank] || 0) + 1;
    });
    return Object.values(ranks).some(count => count === 3);
}

function isTwoPair(cards) {
    const ranks = {};
    cards.forEach(card => {
        const rank = card.slice(0, -1);
        ranks[rank] = (ranks[rank] || 0) + 1;
    });
    const pairs = Object.values(ranks).filter(count => count === 2);
    return pairs.length >= 2;
}

function evaluateHand(cards) {
    if (cards.length < 2) return { type: "Sem cartas suficientes", strength: 0 };
    
    let handType = "Carta Alta";
    let strength = 0;
    
    // Evaluate hands in descending order of strength
    if (isRoyalFlush(cards)) {
        handType = "Royal Flush";
        strength = 1;
    } else if (isStraightFlush(cards)) {
        handType = "Straight Flush";
        strength = 0.95;
    } else if (isQuads(cards)) {
        handType = "Quadra";
        strength = 0.9;
    } else if (isFullHouse(cards)) {
        handType = "Full House";
        strength = 0.85;
    } else if (isFlush(cards)) {
        handType = "Flush";
        strength = 0.8;
    } else if (isStraight(cards)) {
        handType = "Sequência";
        strength = 0.75;
    } else if (isThreeOfAKind(cards)) {
        handType = "Trio";
        strength = 0.7;
    } else if (isTwoPair(cards)) {
        handType = "Dois Pares";
        strength = 0.6;
    } else if (isPair(cards)) {
        handType = "Um Par";
        strength = 0.5;
    } else {
        handType = cards.length >= 5 ? "Carta Alta" : "Mão muito baixa";
        strength = 0.3;
    }
    
    return { type: handType, strength };
}

function calculateWinProbability() {
    const handEval = evaluateHand([...playerHand, ...communityCards]);
    let probability = handEval.strength;

    // Position adjustments
    const position = opponents.length;
    const positionBonus = (position / 6) * 0.15; // Up to 15% bonus for late position
    probability += positionBonus;

    // Opponent analysis
    const activeOpponents = opponents.filter(o => o.action !== 'D').length;
    const aggressiveOpponents = opponents.filter(o => o.action === 'A' || o.action === 'PT').length;
    
    // Adjust based on opponent actions and count
    probability *= Math.pow(0.85, activeOpponents); // Reduce probability for each active opponent
    probability *= Math.pow(0.9, aggressiveOpponents); // Further reduce for aggressive opponents

    // Add outs probability
    if (handEval.outs && handEval.outs.length > 0) {
        const outsBonus = (handEval.outs.length / 47) * 0.3; // Max 30% bonus from outs
        probability += outsBonus;
    }

    return Math.min(Math.max(probability, 0), 1);
}

function updateGameState() {
    if (playerHand.length === 2) {
        const handEval = evaluateHand([...playerHand, ...communityCards]);
        let output = `<strong>Força da Mão:</strong> ${handEval.type}<br><br>`;
        
        // Simplified recommendations based on game phase and hand strength
        output += "<strong>Recomendação:</strong><br>";
        
        if (communityCards.length === 0) {
            // Pre-flop
            if (handEval.strength > 0.7) {
                output += "• Mão forte - Aumente a aposta<br>";
            } else if (handEval.strength > 0.5) {
                output += "• Mão média - Pague ou faça aumento moderado<br>";
            } else {
                output += "• Mão fraca - Melhor desistir se houver aumento<br>";
            }
        } else if (communityCards.length === 3) {
            // Flop
            if (handEval.strength > 0.8) {
                output += "• Mão muito forte - Aumente agressivamente<br>";
            } else if (handEval.strength > 0.6) {
                output += "• Boa mão - Continue apostando<br>";
            } else if (handEval.strength > 0.4) {
                output += "• Mão marginal - Considere pagar se barato<br>";
            } else {
                output += "• Mão fraca - Melhor desistir<br>";
            }
        } else {
            // Turn/River
            if (handEval.strength > 0.8) {
                output += "• Mão muito forte - Maximize o valor<br>";
            } else if (handEval.strength > 0.6) {
                output += "• Mão forte - Continue apostando<br>";
            } else {
                output += "• Mão fraca - Check/Fold<br>";
            }
        }

        const activeOpponents = opponents.filter(o => o.action !== 'D').length;
        output += `<br>• ${activeOpponents} oponente(s) ativo(s)<br>`;
        
        document.getElementById('recommendation').innerHTML = output;
        document.getElementById('probabilities').innerHTML = '';
        document.getElementById('opponent-analysis').style.display = 'none';
    }
}

function generateOpponentHands() {
    opponentHands = [];
    const usedCards = [...playerHand, ...communityCards];
    
    // Generate hands for each active opponent
    opponents.forEach((opponent, index) => {
        if (opponent.action === 'D') {
            opponentHands[index] = [];
            return;
        }

        let availableCards = deck.filter(card => !usedCards.includes(card));
        let opponentHand = [];

        // Probabilistic hand generation based on opponent action
        if (opponent.action === 'A' || opponent.action === 'PT') {
            // Higher chance of premium hands
            const premiumCards = availableCards.filter(card => 
                card.startsWith('A') || card.startsWith('K') || 
                card.startsWith('Q') || card.startsWith('J')
            );
            
            if (premiumCards.length >= 2) {
                opponentHand = premiumCards.slice(0, 2);
            }
        } else if (opponent.action === 'P') {
            // Medium strength hands
            const mediumCards = availableCards.filter(card => 
                !card.startsWith('2') && !card.startsWith('3') &&
                !card.startsWith('4') && !card.startsWith('5')
            );
            
            if (mediumCards.length >= 2) {
                opponentHand = mediumCards.slice(0, 2);
            }
        }

        // If no specific hand was generated, choose random cards
        if (opponentHand.length < 2) {
            while (opponentHand.length < 2 && availableCards.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableCards.length);
                opponentHand.push(availableCards[randomIndex]);
                availableCards.splice(randomIndex, 1);
            }
        }

        opponentHands[index] = opponentHand;
        usedCards.push(...opponentHand);
    });
}

// Add this helper function that was also missing
function hasStraightDraw(cards) {
    if (cards.length < 3) return false;
    
    // Convert cards to ranks and sort them
    const ranks = cards.map(card => values.indexOf(card.slice(0, -1))).sort((a, b) => a - b);
    const uniqueRanks = [...new Set(ranks)];
    
    // Check for consecutive cards
    let maxConsecutive = 1;
    let currentConsecutive = 1;
    
    for (let i = 1; i < uniqueRanks.length; i++) {
        if (uniqueRanks[i] === uniqueRanks[i-1] + 1) {
            currentConsecutive++;
            maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
        } else {
            currentConsecutive = 1;
        }
    }
    
    // Special case for Ace-low straight
    if (ranks.includes(values.length - 1)) { // If there's an Ace
        const lowAceRanks = [...ranks.filter(r => r < 4), -1]; // Consider Ace as -1 for low straight
        lowAceRanks.sort((a, b) => a - b);
        
        let lowConsecutive = 1;
        for (let i = 1; i < lowAceRanks.length; i++) {
            if (lowAceRanks[i] === lowAceRanks[i-1] + 1) {
                lowConsecutive++;
                maxConsecutive = Math.max(maxConsecutive, lowConsecutive);
            } else {
                break;
            }
        }
    }
    
    // Return true if we have 4 consecutive cards (one card away from straight)
    // or if we already have a straight
    return maxConsecutive >= 4;
}

function initializeOpponents(count) {
    opponents = Array(count).fill(null).map((_, i) => ({
        id: i + 1,
        action: 'C',
        aggression: 0,
        lastBet: 0
    }));
}

function createOpponentPanel(opponent) {
    const actions = ['C', 'A', 'P', 'D', 'PT'];
    const actionLabels = {
        'C': 'C',  // Check
        'A': 'A',  // Aumentar
        'P': 'P',  // Pagar
        'D': 'D',  // Desistir 
        'PT': 'PT' // Pot/All-in
    };
    
    const panel = document.createElement('div');
    panel.className = 'opponent-panel';
    panel.innerHTML = `
        <div>Oponente ${opponent.id}</div>
        <div>
            ${actions.map(action => `
                <button onclick="setOpponentAction(${opponent.id}, '${action}')" 
                        id="btn-${opponent.id}-${action}"
                        class="${opponent.action === action ? 'active' : ''}">
                    ${actionLabels[action]}
                </button>
            `).join('')}
        </div>
    `;
    return panel;
}

function setOpponentAction(opponentId, action) {
    const opponent = opponents.find(o => o.id === opponentId);
    if (opponent) {
        opponent.action = action;
        if (action === 'A' || action === 'PT') {
            opponent.aggression++;
        }
        updateOpponentControls();
        updateGameState();
    }
}

function updateOpponentControls() {
    const count = parseInt(document.getElementById('opponentCount').value);
    initializeOpponents(count);
    const container = document.getElementById('opponentActions');
    container.innerHTML = '';
    opponents.forEach(opponent => {
        container.appendChild(createOpponentPanel(opponent));
    });
    generateOpponentHands(); // Generate opponent hands when updated
}

function initializeDeck() {
    deck = [];
    // First create all cards in the desired order
    values.forEach(value => {
        suits.forEach(suit => {
            deck.push(`${value}${suit}`);
        });
    });
    renderDeck();
}

function renderDeck() {
    const deckElement = document.getElementById('deck');
    deckElement.innerHTML = '';
    deck.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.includes('♥') || card.includes('♦') ? 'red' : 'black'}`;
        cardElement.textContent = card;
        cardElement.addEventListener('click', () => toggleCardSelection(card, cardElement));
        deckElement.appendChild(cardElement);
    });
}

function toggleCardSelection(card, cardElement) {
    if (cardElement.classList.contains('selected-hand') || 
        cardElement.classList.contains('selected-community')) {
        // Remove selection
        if (cardElement.classList.contains('selected-hand')) {
            playerHand = playerHand.filter(c => c !== card);
            currentPhase = 'hand'; // Reset to hand phase if removing hand card
        } else {
            communityCards = communityCards.filter(c => c !== card);
            // Adjust phase based on remaining community cards
            if (communityCards.length < 3) currentPhase = 'pre-flop';
            else if (communityCards.length === 3) currentPhase = 'flop';
            else if (communityCards.length === 4) currentPhase = 'river';
        }
        cardElement.className = `card ${card.includes('♥') || card.includes('♦') ? 'red' : 'black'}`;
    } else {
        // Add new selection based on current phase
        if (currentPhase === 'hand' && playerHand.length < 2) {
            playerHand.push(card);
            cardElement.classList.add('selected-hand');
            if (playerHand.length === 2) currentPhase = 'pre-flop';
        } else if (currentPhase === 'pre-flop' && communityCards.length < 3) {
            communityCards.push(card);
            cardElement.classList.add('selected-community', 'pre-flop');
            if (communityCards.length === 3) currentPhase = 'flop';
        } else if (currentPhase === 'flop' && communityCards.length === 3) {
            communityCards.push(card);
            cardElement.classList.add('selected-community', 'turn');
            currentPhase = 'river';
        } else if (currentPhase === 'river' && communityCards.length === 4) {
            communityCards.push(card);
            cardElement.classList.add('selected-community', 'river');
        }
    }
    updateGameState();
}

// Enhanced possible hands analysis
function getPossibleHands() {
    const cards = [...playerHand, ...communityCards];
    const availableCards = deck.filter(card => !cards.includes(card));
    const { outs, odds } = calculateOutsAndOdds(cards, availableCards);
    
    let possibilities = [];
    
    if (odds.flush) {
        possibilities.push(`Flush draw: ${odds.flush.toFixed(1)}% de chance`);
    }
    
    if (odds.straight) {
        possibilities.push(`Straight draw: ${odds.straight.toFixed(1)}% de chance`);
    }
    
    if (odds.set) {
        possibilities.push(`Set draw: ${odds.set.toFixed(1)}% de chance`);
    }
    
    return possibilities.length ? 
        possibilities.join('\n') : 
        "Sem sequências significativas no momento";
}

// Helper function to find straight completion cards
function findStraightCompletionCards(cards) {
    const ranks = cards.map(card => values.indexOf(card.slice(0, -1))).sort((a, b) => a - b);
    const uniqueRanks = [...new Set(ranks)];
    const possibleRanks = [];
    
    for (let i = 0; i < values.length - 4; i++) {
        const window = uniqueRanks.filter(r => r >= i && r <= i + 4);
        if (window.length >= 3) {
            for (let j = i; j <= i + 4; j++) {
                if (!window.includes(j)) {
                    possibleRanks.push(values[j]);
                }
            }
        }
    }
    
    return [...new Set(possibleRanks)];
}

// Enhanced opponent analysis based on actions
function analyzeOpponentBehavior(opponent, handStrength) {
    let analysis = `Oponente ${opponent.id}: `;
    
    switch(opponent.action) {
        case 'C':
            analysis += `• Check sugere: ${
                handStrength > 0.7 ? "Possível slow play - mão forte" :
                handStrength > 0.4 ? "Mão mediana ou draw" :
                "Mão fraca ou esperando ver próxima carta"
            }\n`;
            break;
        case 'A':
            analysis += `• Aumento sugere: ${
                opponent.aggression > 2 ? "Jogador muito agressivo - possível blefe" :
                handStrength > 0.6 ? "Força real na mão" :
                "Tentando roubar o pote"
            }\n`;
            break;
        case 'P':
            analysis += `• Pagou sugere: ${
                handStrength > 0.5 ? "Provavelmente tem uma mão média a forte" :
                "Pode estar em draw ou com mão marginal"
            }\n`;
            break;
        case 'D':
            analysis += "• Desistiu - mão fraca ou sem valor\n";
            break;
        case 'PT':
            analysis += `• All-in sugere: ${
                handStrength > 0.8 ? "Muito provavelmente tem nuts" :
                handStrength > 0.6 ? "Mão forte ou semi-blefe com draw" :
                "Possível blefe ou move desesperado"
            }\n`;
            break;
    }
    
    return analysis;
}

// New function for enhanced predicted hands
function getEnhancedPredictedHands() {
    let analysis = '';
    opponents.forEach((opponent, index) => {
        if (opponent.action === 'D') {
            analysis += `Oponente ${opponent.id}: Desistiu da mão\n`;
            return;
        }

        const opponentCards = opponentHands[index];
        if (!opponentCards || opponentCards.length === 0) {
            analysis += `Oponente ${opponent.id}: Cartas desconhecidas\n`;
            return;
        }

        const allCards = [...opponentCards, ...communityCards];
        const handEval = evaluateHand(allCards);
        let opponentAnalysis = analyzeOpponentBehavior(opponent, handEval.strength);
        
        analysis += opponentAnalysis + `• Mão atual: ${handEval.type}\n`;
        
        // Análise de draws
        if (hasStraightDraw(allCards)) {
            analysis += `• Possível draw para sequência\n`;
        }
        
        const suitCount = {};
        allCards.forEach(card => {
            const suit = card.slice(-1);
            suitCount[suit] = (suitCount[suit] || 0) + 1;
        });
        
        if (Math.max(...Object.values(suitCount)) >= 4) {
            analysis += `• Possível draw para flush\n`;
        }

        analysis += '\n';
    });

    return analysis;
}

// Inicialização
initializeDeck();
updateOpponentControls();
</script>

</body></html>
