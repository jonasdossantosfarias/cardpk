<html><head><base href="/" />
<title>Análise de Poker Inteligente</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
        background-color: #f8f9fa;
        color: #212529;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
    }
    h2 {
        font-size: 1.5rem;
        color: #495057;
        margin: 20px 0 10px 0;
    }
    .deck {
        display: grid;
        grid-template-columns: repeat(13, minmax(40px, 1fr));
        grid-template-rows: repeat(4, auto);
        gap: 8px;
        justify-content: center;
        padding: 10px;
        background: #ffffff;
        border: 1px solid #ced4da;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        margin-top: 20px;
        width: 95%;
        max-width: 1200px;
    }
    .card {
        width: 100%;
        aspect-ratio: 0.7;
        min-width: 30px;
        max-width: 50px;
        height: auto;
        border-radius: 5px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        display: flex;
        justify-content: center;
        align-items: center;
        font-weight: bold;
        font-size: clamp(10px, 2vw, 14px);
        cursor: pointer;
        transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        position: relative;
        overflow: hidden;
        background-color: #ffffff;
        border: 1px solid #ced4da;
    }
    .card:before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(255,255,255,0.4) 0%, rgba(255,255,255,0) 50%);
        pointer-events: none;
    }
    .card.red { color: #e74c3c; }
    .card.black { color: #212529; }
    .card:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
    }
    .selected-hand {
        background-color: #3498db;
        color: white !important;
        border-color: #2980b9;
        box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
    }
    .selected-community.pre-flop {
        background-color: #e67e22;
        color: white !important;
        border-color: #d35400;
        box-shadow: 0 4px 8px rgba(230, 126, 34, 0.3);
    }
    .selected-community.turn {
        background-color: #9b59b6;
        color: white !important;
        border-color: #8e44ad;
        box-shadow: 0 4px 8px rgba(155, 89, 182, 0.3);
    }
    .selected-community.river {
        background-color: #e74c3c;
        color: white !important;
        border-color: #c0392b;
        box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
    }
    .controls {
        margin: 20px 0;
        padding: 15px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        width: 95%;
        max-width: 800px;
    }
    .opponent-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin: 10px 0;
        width: 95%;
        max-width: 800px;
    }
    .opponent-panel {
        background: #f8f9fa;
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #dee2e6;
    }
    button {
        padding: 8px 15px;
        font-size: 14px;
        border: none;
        background-color: #3498db;
        color: white;
        border-radius: 5px;
        cursor: pointer;
        margin: 2px;
    }
    button:hover {
        opacity: 0.9;
    }
    button.active {
        background-color: #e74c3c;
    }
    .info-container {
        margin: 15px;
        padding: 15px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        width: 95%;
        max-width: 800px;
    }
    select {
        padding: 5px 10px;
        border-radius: 5px;
        border: 1px solid #ced4da;
        margin-right: 10px;
    }
    @media (max-width: 768px) {
        .deck {
            gap: 4px;
            padding: 5px;
        }
        
        .card {
            min-width: 25px;
        }
    }

    @media (max-width: 480px) {
        .deck {
            gap: 2px;
            padding: 3px;
        }
    }
</style>
</head>
<body>
    <h2>Análise de Poker Inteligente</h2>
    <div class="controls">
        <select id="opponentCount">
            <option value="1">1 Oponente</option>
            <option value="2">2 Oponentes</option>
            <option value="3">3 Oponentes</option>
            <option value="4">4 Oponentes</option>
        </select>
        <button onclick="updateOpponentControls()">Atualizar Oponentes</button>
    </div>
    <div id="opponentActions" class="opponent-controls"></div>
    <div class="info-container">
        <div id="recommendation" style="margin-bottom: 10px; font-size: 16px; color: #343a40;">Recomendação: </div>
        <div id="probabilities" style="margin-bottom: 10px; font-size: 14px; color: #6c757d;">Probabilidades: </div>
        <div id="opponent-analysis" style="font-size: 14px; color: #6c757d;">Análise dos oponentes: </div>
        <div id="predicted-hands" style="font-size: 14px; color: #6c757d; margin-top: 10px;">Mãos prováveis dos oponentes: </div>
    </div>
    <div class="deck" id="deck"></div>

<script>
const suits = ['♥', '♦', '♣', '♠'];
const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
let deck = [];
let playerHand = [];
let communityCards = [];
let opponents = [];
let currentPhase = 'hand'; // Can be: 'hand', 'pre-flop', 'flop', 'river'
let opponentHands = [];

let blinds = {
    small: 10,
    big: 20
};

function getBlindsString() {
    return `Small: ${blinds.small}, Big: ${blinds.big}`;
}

function getKickersString(cards) {
    if (cards.length < 2) return [];
    const ranks = cards.map(card => card.slice(0, -1));
    return ranks.sort((a,b) => values.indexOf(b) - values.indexOf(a)).slice(1);
}

function isStraightFlush(cards) {
    return isFlush(cards) && isStraight(cards);
}

function isRoyalFlush(cards) {
    return isStraightFlush(cards) && cards.some(card => card.startsWith('A'));
}

function isFlush(cards) {
    if (cards.length < 5) return false;
    const suits = cards.map(card => card.slice(-1));
    return suits.every(suit => suit === suits[0]);
}

function isStraight(cards) {
    if (cards.length < 5) return false;
    const ranks = cards.map(card => values.indexOf(card.slice(0, -1))).sort((a, b) => a - b);
    for (let i = 1; i < ranks.length; i++) {
        if (ranks[i] !== ranks[i-1] + 1) return false;
    }
    return true;
}

function isPair(cards) {
    const ranks = cards.map(card => card.slice(0, -1));
    return new Set(ranks).size < ranks.length;
}

function isFullHouse(cards) {
    const rankCounts = {};
    cards.forEach(card => {
        const rank = card.slice(0, -1);
        rankCounts[rank] = (rankCounts[rank] || 0) + 1;
    });
    return Object.values(rankCounts).includes(3) && Object.values(rankCounts).includes(2);
}

function evaluateHand(cards) {
    if (cards.length < 2) return { type: "Sem cartas suficientes", strength: 0 };

    const ranks = cards.map(card => card.slice(0, -1));
    const suits = cards.map(card => card.slice(-1));
    const rankCounts = {};
    ranks.forEach(rank => rankCounts[rank] = (rankCounts[rank] || 0) + 1);

    // Avaliações mais detalhadas
    if (isRoyalFlush(cards)) return { 
        type: "Royal Flush", 
        strength: 1, 
        description: "Mão mais forte possível! Considere slow play apenas se houver muita ação" 
    };
    
    if (isStraightFlush(cards)) return { 
        type: "Straight Flush", 
        strength: 0.95, 
        description: "Mão monstruosa! Maximize o valor do pote" 
    };
    
    const fourKind = Object.entries(rankCounts).find(([_, count]) => count === 4);
    if (fourKind) {
        return { 
            type: "Poker", 
            strength: 0.9,
            description: `Poker de ${fourKind[0]}s - Mão dominante, controle o tamanho do pote`
        };
    }

    if (isFullHouse(cards)) {
        const threeKind = Object.entries(rankCounts).find(([_, count]) => count === 3);
        const pair = Object.entries(rankCounts).find(([_, count]) => count === 2);
        return { 
            type: "Full House", 
            strength: 0.85,
            description: `Full House de ${threeKind[0]}s com carta secundária de ${pair[0]}s - Mão muito forte contra ranges`
        };
    }

    if (isFlush(cards)) {
        const flushCards = cards.filter(card => card.endsWith(suits[0]));
        const highCard = Math.max(...flushCards.map(card => values.indexOf(card.slice(0, -1))));
        return { 
            type: "Flush", 
            strength: 0.8,
            description: `Flush de ${suits[0]} com ${values[highCard]} alta - Forte, mas vulnerável a Full Houses`
        };
    }

    if (isStraight(cards)) {
        const highCard = Math.max(...ranks.map(r => values.indexOf(r)));
        return { 
            type: "Sequência", 
            strength: 0.75,
            description: `Sequência até ${values[highCard]} - Mão forte mas vulnerável a Flushes`
        };
    }

    const threeKind = Object.entries(rankCounts).find(([_, count]) => count === 3);
    if (threeKind) {
        const kickers = ranks.filter(r => r !== threeKind[0]).sort((a,b) => values.indexOf(b) - values.indexOf(a));
        return { 
            type: "Trinca", 
            strength: 0.7,
            description: `Trinca de ${threeKind[0]}s com cartas secundárias ${kickers.slice(0,2).join(', ')}`
        };
    }

    const pairs = Object.entries(rankCounts).filter(([_, count]) => count === 2);
    if (pairs.length === 2) {
        const orderedPairs = pairs.sort((a,b) => values.indexOf(b[0]) - values.indexOf(a[0]));
        const kicker = ranks.find(r => !orderedPairs.find(p => p[0] === r));
        return { 
            type: "Dois Pares", 
            strength: values.indexOf(orderedPairs[0][0]) > 10 ? 0.65 : 0.6,
            description: `Dois pares: ${orderedPairs[0][0]}s e ${orderedPairs[1][0]}s com carta secundária ${kicker}`
        };
    }

    if (pairs.length === 1) {
        const pairRank = pairs[0][0];
        const kickers = ranks.filter(r => r !== pairRank)
            .sort((a,b) => values.indexOf(b) - values.indexOf(a));
        const isHighPair = values.indexOf(pairRank) >= values.indexOf('J');
        const isMediumPair = values.indexOf(pairRank) >= values.indexOf('8');
        return { 
            type: "Um Par", 
            strength: isHighPair ? 0.5 : (isMediumPair ? 0.45 : 0.4),
            description: `Par de ${pairRank}s com cartas secundárias ${kickers.join(', ')} - ${
                isHighPair ? 'Par alto' : (isMediumPair ? 'Par médio' : 'Par baixo')}`
        };
    }

    // Carta alta com análise completa
    const sortedRanks = [...new Set(ranks)]
        .sort((a,b) => values.indexOf(b) - values.indexOf(a));
    const highCard = sortedRanks[0];
    const strength = values.indexOf(highCard) / values.length;
    
    let description = `${highCard} alta com `;
    if (sortedRanks.length > 1) {
        description += `cartas secundárias ${sortedRanks.slice(1).join(', ')} - `;
    }
    
    if (values.indexOf(highCard) >= values.indexOf('Q')) {
        description += 'Carta alta premium';
    } else if (values.indexOf(highCard) >= values.indexOf('J')) {
        description += 'Carta alta marginal';
    } else {
        description += 'Carta alta muito fraca';
    }

    return { 
        type: "Carta Alta", 
        strength: strength * 0.35, // Reduzido para refletir melhor a fraqueza
        description: description
    };
}

function calculateWinProbability() {
    const handEval = evaluateHand([...playerHand, ...communityCards]);
    let probability = handEval.strength;

    const playerPosition = opponents.length;
    const positionBonus = (playerPosition / 4) * 0.1; // Up to 10% bonus for late position
    probability += positionBonus;

    opponents.forEach((opponent, index) => {
        if (opponent.action === 'A') probability *= 0.8;
        if (opponent.action === 'PT') probability *= 0.6;
        if (opponent.action === 'D') probability *= 1.2;
        probability *= (1 - (opponent.aggression * 0.1));

        if (opponent.action === 'A' && index < 2) {
            probability *= 0.9;
        }
    });

    const activeOpponents = opponents.filter(o => o.action !== 'D').length;
    probability *= Math.pow(0.8, activeOpponents);

    return Math.min(Math.max(probability, 0), 1);
}

function updateGameState() {
    if (playerHand.length === 2) {
        const probability = calculateWinProbability();
        const handEval = evaluateHand([...playerHand, ...communityCards]);
        
        let output = `<strong>Força da Mão:</strong> ${handEval.type} - ${handEval.description}<br><br>`;
        
        output += `<strong>Probabilidade de Vitória:</strong> ${(probability * 100).toFixed(1)}%<br><br>`;
        
        output += `<strong>Possíveis sequências:</strong><br>`;
        output += `${getPossibleHands()}<br><br>`;
        
        // Recomendação section
        output += "<strong>Recomendação:</strong><br>";
        const activeOpponents = opponents.filter(o => o.action !== 'D').length;
        const hasPosition = opponents.filter(o => o.action === 'C' || o.action === 'P').length > 0;
        const aggressiveActions = opponents.filter(o => o.action === 'A' || o.action === 'PT').length;
        
        if (probability > 0.8) {
            output += "• Mão muito forte - Ideal para aumento significativo<br>";
            output += hasPosition ? "• Você tem posição - considere um aumento maior<br>" : "";
            output += `• Com ${activeOpponents} oponente(s) ativo(s), maximize o valor<br>`;
            output += aggressiveActions > 0 ? "• Há ação forte - considere re-raise" : "";
        } else if (probability > 0.6) {
            output += "• Mão forte - Bom momento para aumentar<br>";
            output += hasPosition ? "• Use sua posição para controlar o pote<br>" : "";
            output += aggressiveActions > 0 ? "• Avalie cuidadosamente re-raises" : "• Lidere a ação com raise";
        } else if (probability > 0.4) {
            output += "• Mão mediana - Jogue com cautela<br>";
            output += hasPosition ? "• Posição favorável para pagar<br>" : "• Fora de posição - mais cautela";
            output += aggressiveActions > 0 ? "• Muita ação - considere desistir" : "• Check/Pagar é aceitável";
        } else {
            output += "• Mão fraca - Melhor preservar fichas<br>";
            output += "• Recomendado desistir a menos que:<br>";
            output += "  - Apostas mínimas baixas<br>";
            output += "  - Sem aumentos anteriores<br>";
            output += "  - Boa posição para roubar";
        }
        
        document.getElementById('recommendation').innerHTML = output;
        
        // Update predicted hands section
        document.getElementById('predicted-hands').innerHTML = 
            `<strong>Mãos prováveis dos oponentes:</strong><br>${getEnhancedPredictedHands()}`;
        
        // Hide unused elements
        document.getElementById('probabilities').innerHTML = '';
        document.getElementById('opponent-analysis').style.display = 'none';
    }
}

function generateOpponentHands() {
    opponentHands = [];
    const usedCards = [...playerHand, ...communityCards];
    
    // Generate hands for each active opponent
    opponents.forEach((opponent, index) => {
        if (opponent.action === 'D') {
            opponentHands[index] = [];
            return;
        }

        let availableCards = deck.filter(card => !usedCards.includes(card));
        let opponentHand = [];

        // Probabilistic hand generation based on opponent action
        if (opponent.action === 'A' || opponent.action === 'PT') {
            // Higher chance of premium hands
            const premiumCards = availableCards.filter(card => 
                card.startsWith('A') || card.startsWith('K') || 
                card.startsWith('Q') || card.startsWith('J')
            );
            
            if (premiumCards.length >= 2) {
                opponentHand = premiumCards.slice(0, 2);
            }
        } else if (opponent.action === 'P') {
            // Medium strength hands
            const mediumCards = availableCards.filter(card => 
                !card.startsWith('2') && !card.startsWith('3') &&
                !card.startsWith('4') && !card.startsWith('5')
            );
            
            if (mediumCards.length >= 2) {
                opponentHand = mediumCards.slice(0, 2);
            }
        }

        // If no specific hand was generated, choose random cards
        if (opponentHand.length < 2) {
            while (opponentHand.length < 2 && availableCards.length > 0) {
                const randomIndex = Math.floor(Math.random() * availableCards.length);
                opponentHand.push(availableCards[randomIndex]);
                availableCards.splice(randomIndex, 1);
            }
        }

        opponentHands[index] = opponentHand;
        usedCards.push(...opponentHand);
    });
}

// Add this helper function that was also missing
function hasStraightDraw(cards) {
    if (cards.length < 3) return false;
    
    // Convert cards to ranks and sort them
    const ranks = cards.map(card => values.indexOf(card.slice(0, -1))).sort((a, b) => a - b);
    const uniqueRanks = [...new Set(ranks)];
    
    // Check for consecutive cards
    let maxConsecutive = 1;
    let currentConsecutive = 1;
    
    for (let i = 1; i < uniqueRanks.length; i++) {
        if (uniqueRanks[i] === uniqueRanks[i-1] + 1) {
            currentConsecutive++;
            maxConsecutive = Math.max(maxConsecutive, currentConsecutive);
        } else {
            currentConsecutive = 1;
        }
    }
    
    // Special case for Ace-low straight
    if (ranks.includes(values.length - 1)) { // If there's an Ace
        const lowAceRanks = [...ranks.filter(r => r < 4), -1]; // Consider Ace as -1 for low straight
        lowAceRanks.sort((a, b) => a - b);
        
        let lowConsecutive = 1;
        for (let i = 1; i < lowAceRanks.length; i++) {
            if (lowAceRanks[i] === lowAceRanks[i-1] + 1) {
                lowConsecutive++;
                maxConsecutive = Math.max(maxConsecutive, lowConsecutive);
            } else {
                break;
            }
        }
    }
    
    // Return true if we have 4 consecutive cards (one card away from straight)
    // or if we already have a straight
    return maxConsecutive >= 4;
}

function initializeOpponents(count) {
    opponents = Array(count).fill(null).map((_, i) => ({
        id: i + 1,
        action: 'C',
        aggression: 0,
        lastBet: 0
    }));
}

function createOpponentPanel(opponent) {
    const actions = ['C', 'A', 'P', 'D', 'PT'];
    const actionLabels = {
        'C': 'C',  // Check
        'A': 'A',  // Aumentar
        'P': 'P',  // Pagar
        'D': 'D',  // Desistir 
        'PT': 'PT' // Pot/All-in
    };
    
    const panel = document.createElement('div');
    panel.className = 'opponent-panel';
    panel.innerHTML = `
        <div>Oponente ${opponent.id}</div>
        <div>
            ${actions.map(action => `
                <button onclick="setOpponentAction(${opponent.id}, '${action}')" 
                        id="btn-${opponent.id}-${action}"
                        class="${opponent.action === action ? 'active' : ''}">
                    ${actionLabels[action]}
                </button>
            `).join('')}
        </div>
    `;
    return panel;
}

function setOpponentAction(opponentId, action) {
    const opponent = opponents.find(o => o.id === opponentId);
    if (opponent) {
        opponent.action = action;
        if (action === 'A' || action === 'PT') {
            opponent.aggression++;
        }
        updateOpponentControls();
        updateGameState();
    }
}

function updateOpponentControls() {
    const count = parseInt(document.getElementById('opponentCount').value);
    initializeOpponents(count);
    const container = document.getElementById('opponentActions');
    container.innerHTML = '';
    opponents.forEach(opponent => {
        container.appendChild(createOpponentPanel(opponent));
    });
    generateOpponentHands(); // Generate opponent hands when updated
}

function initializeDeck() {
    deck = [];
    // First create all cards in the desired order
    values.forEach(value => {
        suits.forEach(suit => {
            deck.push(`${value}${suit}`);
        });
    });
    renderDeck();
}

function renderDeck() {
    const deckElement = document.getElementById('deck');
    deckElement.innerHTML = '';
    deck.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.includes('♥') || card.includes('♦') ? 'red' : 'black'}`;
        cardElement.textContent = card;
        cardElement.addEventListener('click', () => toggleCardSelection(card, cardElement));
        deckElement.appendChild(cardElement);
    });
}

function toggleCardSelection(card, cardElement) {
    if (cardElement.classList.contains('selected-hand') || 
        cardElement.classList.contains('selected-community')) {
        // Remove selection
        if (cardElement.classList.contains('selected-hand')) {
            playerHand = playerHand.filter(c => c !== card);
            currentPhase = 'hand'; // Reset to hand phase if removing hand card
        } else {
            communityCards = communityCards.filter(c => c !== card);
            // Adjust phase based on remaining community cards
            if (communityCards.length < 3) currentPhase = 'pre-flop';
            else if (communityCards.length === 3) currentPhase = 'flop';
            else if (communityCards.length === 4) currentPhase = 'river';
        }
        cardElement.className = `card ${card.includes('♥') || card.includes('♦') ? 'red' : 'black'}`;
    } else {
        // Add new selection based on current phase
        if (currentPhase === 'hand' && playerHand.length < 2) {
            playerHand.push(card);
            cardElement.classList.add('selected-hand');
            if (playerHand.length === 2) currentPhase = 'pre-flop';
        } else if (currentPhase === 'pre-flop' && communityCards.length < 3) {
            communityCards.push(card);
            cardElement.classList.add('selected-community', 'pre-flop');
            if (communityCards.length === 3) currentPhase = 'flop';
        } else if (currentPhase === 'flop' && communityCards.length === 3) {
            communityCards.push(card);
            cardElement.classList.add('selected-community', 'turn');
            currentPhase = 'river';
        } else if (currentPhase === 'river' && communityCards.length === 4) {
            communityCards.push(card);
            cardElement.classList.add('selected-community', 'river');
        }
    }
    updateGameState();
}

// Enhanced possible hands analysis
function getPossibleHands() {
    const cards = [...playerHand, ...communityCards];
    let possibilities = [];
    
    // Analyze flush possibilities
    const suitCount = {};
    cards.forEach(card => {
        const suit = card.slice(-1);
        suitCount[suit] = (suitCount[suit] || 0) + 1;
    });
    
    Object.entries(suitCount).forEach(([suit, count]) => {
        if (count >= 4) {
            const neededSuit = suit;
            const remainingCards = deck.filter(card => 
                !cards.includes(card) && card.endsWith(neededSuit)
            );
            possibilities.push(`Flush draw com ${count} cartas de ${suit}. Cartas que completam: ${remainingCards.join(', ')}`);
        }
    });
    
    // Analyze straight possibilities
    if (hasStraightDraw(cards)) {
        const possibleCompletions = findStraightCompletionCards(cards);
        possibilities.push(`Draw de sequência - Cartas que completam: ${possibleCompletions.join(', ')}`);
    }
    
    // Add pair analysis with specific completions
    const rankCount = {};
    cards.forEach(card => {
        const rank = card.slice(0, -1);
        rankCount[rank] = (rankCount[rank] || 0) + 1;
    });
    
    Object.entries(rankCount).forEach(([rank, count]) => {
        if (count === 2) {
            const possibleCompletions = deck.filter(card => 
                !cards.includes(card) && card.startsWith(rank)
            );
            possibilities.push(`Par de ${rank}s - Trinca possível com: ${possibleCompletions.join(', ')}`);
        }
    });
    
    return possibilities.length ? possibilities.join('\n') : "Sem sequências significativas no momento";
}

// Helper function to find straight completion cards
function findStraightCompletionCards(cards) {
    const ranks = cards.map(card => values.indexOf(card.slice(0, -1))).sort((a, b) => a - b);
    const uniqueRanks = [...new Set(ranks)];
    const possibleRanks = [];
    
    for (let i = 0; i < values.length - 4; i++) {
        const window = uniqueRanks.filter(r => r >= i && r <= i + 4);
        if (window.length >= 3) {
            for (let j = i; j <= i + 4; j++) {
                if (!window.includes(j)) {
                    possibleRanks.push(values[j]);
                }
            }
        }
    }
    
    return [...new Set(possibleRanks)];
}

// Enhanced opponent analysis based on actions
function analyzeOpponentBehavior(opponent, handStrength) {
    let analysis = `Oponente ${opponent.id}: `;
    
    switch(opponent.action) {
        case 'C':
            analysis += `• Check sugere: ${
                handStrength > 0.7 ? "Possível slow play - mão forte" :
                handStrength > 0.4 ? "Mão mediana ou draw" :
                "Mão fraca ou esperando ver próxima carta"
            }\n`;
            break;
        case 'A':
            analysis += `• Aumento sugere: ${
                opponent.aggression > 2 ? "Jogador muito agressivo - possível blefe" :
                handStrength > 0.6 ? "Força real na mão" :
                "Tentando roubar o pote"
            }\n`;
            break;
        case 'P':
            analysis += `• Pagou sugere: ${
                handStrength > 0.5 ? "Provavelmente tem uma mão média a forte" :
                "Pode estar em draw ou com mão marginal"
            }\n`;
            break;
        case 'D':
            analysis += "• Desistiu - mão fraca ou sem valor\n";
            break;
        case 'PT':
            analysis += `• All-in sugere: ${
                handStrength > 0.8 ? "Muito provavelmente tem nuts" :
                handStrength > 0.6 ? "Mão forte ou semi-blefe com draw" :
                "Possível blefe ou move desesperado"
            }\n`;
            break;
    }
    
    return analysis;
}

// New function for enhanced predicted hands
function getEnhancedPredictedHands() {
    let analysis = '';
    opponents.forEach((opponent, index) => {
        if (opponent.action === 'D') {
            analysis += `Oponente ${opponent.id}: Desistiu da mão\n`;
            return;
        }

        const opponentCards = opponentHands[index];
        if (!opponentCards || opponentCards.length === 0) {
            analysis += `Oponente ${opponent.id}: Cartas desconhecidas\n`;
            return;
        }

        const allCards = [...opponentCards, ...communityCards];
        const handEval = evaluateHand(allCards);
        let opponentAnalysis = analyzeOpponentBehavior(opponent, handEval.strength);
        
        analysis += opponentAnalysis + `• Mão atual: ${handEval.type}\n`;
        
        // Análise de draws
        if (hasStraightDraw(allCards)) {
            analysis += `• Possível draw para sequência\n`;
        }
        
        const suitCount = {};
        allCards.forEach(card => {
            const suit = card.slice(-1);
            suitCount[suit] = (suitCount[suit] || 0) + 1;
        });
        
        if (Math.max(...Object.values(suitCount)) >= 4) {
            analysis += `• Possível draw para flush\n`;
        }

        analysis += '\n';
    });

    return analysis;
}

// Inicialização
initializeDeck();
updateOpponentControls();
</script>

</body></html>
